<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Getting Practical with R: Real-World Tips for Cleaner Data | DataCraft</title>
  <style>
    body {
      font-family: 'Georgia', serif;
      background-color: #ffffff;
      margin: 0;
      padding: 0;
      color: #333;
      line-height: 1.7;
    }

    header {
      background-color: #222;
      color: #fff;
      padding: 20px 40px;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: 1.8em;
      font-weight: normal;
    }

    .container {
      max-width: 750px;
      margin: auto;
      padding: 40px 20px;
    }

    h2 {
      font-size: 1.5em;
      margin-top: 40px;
      color: #111;
    }

    .code-block {
      background-color: #f4f4f4;
      padding: 15px;
      border-left: 4px solid #ff9900;
      font-family: monospace;
      white-space: pre-wrap;
      border-radius: 4px;
      overflow-x: auto;
      margin: 20px 0;
    }

    footer {
      background-color: #f0f0f0;
      color: #777;
      text-align: center;
      padding: 20px;
      font-size: 0.9em;
      margin-top: 60px;
    }

    a {
      color: #0066cc;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    ul {
      padding-left: 20px;
    }

    p.intro {
      font-size: 1.1em;
      margin-top: 0;
    }
  </style>
  <script>
    function crashPage() {
      throw new Error("Simulated crash triggered.");
    }
  </script>
</head>
<body>
  <header>
    <h1>DataCraft Blog</h1>
  </header>

  <div class="container">
    <h2>Getting Practical with R: Real-World Tips for Cleaner Data</h2>
    <p class="intro">
      R is an incredibly powerful tool for data science, but it shines the most when you apply it to real problems with real messiness. In this post, I’ve collected some of the most useful techniques I’ve picked up over the years for making R work better in practical, sometimes chaotic, situations.
    </p>

    <h2>1. Audit Your Data Types Early</h2>
    <p>
      Before you jump into any analysis, always verify your data types. Mismatches between numeric and factor columns can silently break your models. Here's a simple but effective check:
    </p>
    <div class="code-block">
<code>
# Preview structure of the data
str(my_data)

# Check column types individually
sapply(my_data, class)
</code>
    </div>
    <p>
      Be especially cautious with character data. By default, older versions of R convert strings to factors automatically. Consider starting scripts with:
    </p>
    <div class="code-block">
<code>
options(stringsAsFactors = FALSE)
</code>
    </div>

    <h2>2. Clean Column Names Automatically</h2>
    <p>
      Working with ugly column names? The <code>janitor</code> package makes them human- and code-friendly in one go:
    </p>
    <div class="code-block">
<code>
library(janitor)

# Fix messy column names
clean_data &lt;- my_data %&gt;% clean_names()
</code>
    </div>
    <p>This converts names like <code>"% Total Revenue"</code> into <code>"percent_total_revenue"</code>, which is easier to use in code and more consistent with tidyverse practices.</p>

    <h2>3. Classify Outliers with Ordered Factors</h2>
    <p>
      Sometimes you don’t want to remove outliers—you want to label them. Here’s how I classified outliers in R and converted the result into an ordered factor:
    </p>
    <div class="code-block">
<code>
# Get outlier thresholds for FirstGen
fg_thresh = outlier.vals(CollegeData$FirstGen)

# Label values based on outlier thresholds
firstgen.out = ifelse(CollegeData$FirstGen &lt; fg_thresh["low.val"], "low",
               ifelse(CollegeData$FirstGen &gt; fg_thresh["high.val"], "high", "good"))

# Convert to ordered factor with levels: low &lt; good &lt; high
firstgen.out &lt;- factor(firstgen.out, levels = c("low", "good", "high"), ordered = TRUE)

# Display count of each category
table(firstgen.out)
</code>
    </div>

    <h2>4. Handle Missing Data Strategically</h2>
    <p>
      NA values aren't just nuisances—they're data in their own right. Use <code>skimr</code> for a high-level overview:
    </p>
    <div class="code-block">
<code>
library(skimr)
skim(my_data)
</code>
    </div>
    <p>
      If you're filling missing values, avoid blanket replacements. Use conditional logic:
    </p>
    <div class="code-block">
<code>
# Replace missing ages with median, grouped by gender
library(dplyr)
my_data &lt;- my_data %&gt;%
  group_by(gender) %&gt;%
  mutate(age = ifelse(is.na(age), median(age, na.rm = TRUE), age))
</code>
    </div>

    <h2>5. Use `case_when()` to Simplify Complex Conditions</h2>
    <p>
      Nested <code>ifelse()</code> statements can get unwieldy. <code>dplyr::case_when()</code> makes complex logic readable:
    </p>
    <div class="code-block">
<code>
my_data &lt;- my_data %&gt;%
  mutate(risk_category = case_when(
    score &lt; 50 ~ "Low",
    score &gt;= 50 &amp; score &lt; 80 ~ "Moderate",
    score &gt;= 80 ~ "High"
  ))
</code>
    </div>
    <p>It’s like a switch-case statement in other languages—much cleaner than nested ifs.</p>

    <h2>Wrapping Up</h2>
    <p>
      These R tricks are the result of trial, error, and a lot of project time. Whether you're prepping for analysis or debugging unexpected model output, taking time to handle your data correctly up front pays huge dividends. Let me know if you’d like a follow-up post on visualization or modeling best practices!
    </p>
    <p>
      *All contact information and author names have been removed from the archive by their request
    </p>
  </div>

  <footer>
    © 2018 DataCraft. All rights reserved. |
    <a href="#" onclick="crashPage()">Privacy</a> |
    <a href="#" onclick="crashPage()">About</a>
  </footer>
</body>
</html>
